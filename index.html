<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CFB Rankings 2025</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      background: #f4f4f4;
    }
    h1 {
      text-align: center;
    }
    #table-wrapper {
      overflow-x: auto;
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
      margin-top: 10px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 13px;
    }
    thead {
      position: sticky;
      top: 0;
      background: #000000;
      color: white;
    }
    th, td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      text-align: right;
    }
    th:nth-child(2),
    th:nth-child(3),
    td:nth-child(2),
    td:nth-child(3) {
      text-align: left; /* Team / Conference or similar text columns */
    }
    tr:nth-child(even) {
      background: #f9f9f9;
    }
    tr:hover {
      background: #3f3f3f;
    }
    th.sortable {
      cursor: pointer;
    }
    th.sortable::after {
      content: " ↕";
      font-size: 0.7em;
      opacity: 0.6;
    }
  </style>
</head>
<body>
  <h1>CFB Efficiency Rankings 2025</h1>
  <p style="text-align:center;">Data Updated 5:50pm 12/7/2025</p>

  <div id="table-wrapper">
    <table id="rankings">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>

<script>
    // Your CSV file on GitHub (RAW URL)
    const csvUrl =
      "https://raw.githubusercontent.com/EricAGonzalz/CFBRankings/main/Dec7%20CFB%20Rankings.csv";

    let allRows = [];
    let currentHeader = [];
    let conferenceIndex = -1;

    function parseCSV(text) {
      const lines = text.trim().split(/\r?\n/);
      if (lines.length === 0) {
        return { header: [], rows: [] };
      }
      const header = lines[0].split(",");
      const rows = lines.slice(1).map(line => line.split(","));
      return { header, rows };
    }

    function buildTable(header, rows) {
      currentHeader = header;
      allRows = rows;
      conferenceIndex = header.indexOf("Conference");

      const table = document.getElementById("rankings");
      const thead = table.querySelector("thead");

      thead.innerHTML = "";

      // Build header row
      const headerRow = document.createElement("tr");
      header.forEach((col, idx) => {
        const th = document.createElement("th");
        th.textContent = col;
        th.classList.add("sortable");
        th.dataset.index = idx;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);

      // Initial body render (all rows)
      renderBody(allRows);

      // Init conference dropdown
      initConferenceFilter();

      // Enable sorting
      makeSortable(table);
    }

    function renderBody(rows) {
      const table = document.getElementById("rankings");
      const tbody = table.querySelector("tbody");
      tbody.innerHTML = "";

      rows.forEach(cells => {
        if (!cells.join("").trim()) return;
        const tr = document.createElement("tr");
        cells.forEach(cell => {
          const td = document.createElement("td");
          td.textContent = cell;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
    }

    function initConferenceFilter() {
      const select = document.getElementById("confFilter");
      if (conferenceIndex === -1) {
        // No "Conference" column – nothing to do
        return;
      }

      // Build unique sorted list of conferences
      const confSet = new Set();
      allRows.forEach(r => {
        const conf = r[conferenceIndex];
        if (conf && conf.trim() !== "") {
          confSet.add(conf.trim());
        }
      });

      const conferences = Array.from(confSet).sort();
      conferences.forEach(conf => {
        const opt = document.createElement("option");
        opt.value = conf;
        opt.textContent = conf;
        select.appendChild(opt);
      });

      // When user changes conference selection, filter rows
      select.addEventListener("change", () => {
        const value = select.value;
        let filtered;
        if (value === "ALL") {
          filtered = allRows;
        } else {
          filtered = allRows.filter(r => r[conferenceIndex] === value);
        }
        renderBody(filtered);
      });
    }

    function makeSortable(table) {
      const ths = table.querySelectorAll("th.sortable");
      ths.forEach(th => {
        th.addEventListener("click", () => {
          const index = parseInt(th.dataset.index, 10);
          const tbody = table.querySelector("tbody");
          const rows = Array.from(tbody.querySelectorAll("tr"));

          const current = th.dataset.sort || "none";
          const next = current === "asc" ? "desc" : "asc";

          ths.forEach(h => h.dataset.sort = "none");
          th.dataset.sort = next;

          rows.sort((a, b) => {
            const aText = a.children[index].textContent;
            const bText = b.children[index].textContent;

            const aNum = parseFloat(aText);
            const bNum = parseFloat(bText);
            const bothNumeric = !Number.isNaN(aNum) && !Number.isNaN(bNum);

            let cmp;
            if (bothNumeric) {
              cmp = aNum - bNum;
            } else {
              cmp = aText.localeCompare(bText);
            }
            return next === "asc" ? cmp : -cmp;
          });

          rows.forEach(r => tbody.appendChild(r));
        });
      });
    }

    // Fetch CSV and render table
    fetch(csvUrl)
      .then(r => {
        if (!r.ok) {
          throw new Error("HTTP " + r.status);
        }
        return r.text();
      })
      .then(text => {
        const { header, rows } = parseCSV(text);
        if (header.length === 0) {
          console.error("CSV appears to be empty or malformed.");
        }
        buildTable(header, rows);
      })
      .catch(err => {
        console.error("Failed to load CSV:", err);
      });
  </script>
</body>
</html>
